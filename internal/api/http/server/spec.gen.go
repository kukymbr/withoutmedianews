// Package server provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.0 DO NOT EDIT.
package server

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
)

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+xYX2/bNhD/KgQ3YC9a5KbpUOhpad0OBtKswDLsoQiCs3SW2UmkSp7cGoa/+3CkJMu2",
	"bCdLloehT4l85P37/Y6840qmpqyMRk1OJitZgYUSCa3/eguEubHLyZi/MnSpVRUpo2Ui36uC0IrpUqTN",
	"KjEZy0gqFn6p0S5lJDWUKBPZrrhTmYykS+dYAmukZcVipQlztHK9juQN5MetEeSHDRHkJ22sI2nRVUY7",
	"9EGOcQZ1Qe+sNZa/U6MJNfG/UFWFSoF9iD87dmTV0/yjxZlM5A/xJoVxkLr48uMkKPT2tmNpDArkBaL1",
	"Ra4jeW3oval19ixuXBsSM29tHck/dWVNis7BtMB3mhQtn8WJLbuiMczLms2su9vP/LSmQksqQFfyxhz3",
	"6eLXi1YcSfwGZVUwD95AJix+qdGRjFpyOLJK5zJQ40utLGYy+dSpv+0WmulnTIkT1pbGvu1WIsxM0ByF",
	"xq9ORjueq+xU1q7rEq1KJ2O2RooKPGIqyPtxXqapynxVR7KEb1eoc5rL5PzVq1NR+/oJCocCv+ZwmA9F",
	"8ftMJp9ORIFf3Rvw7N4Fr8et7ag+gNKikfaTKMCSSn2cxyNoNe+7f9sE4F3aoxPUNA8026kUKLF1pPFB",
	"NGu3qGWmfslbGKBW1B2Cp4DvmLWOHkqTqp4Wys0xuwM6tfFGlegIyoo3urmxdEf4bQCOjxah5OpsMlAZ",
	"3jb1OPSY9WJ0fjEQdTiR3UBSGVGC3InJmEmqCEs3dGB3SsFaWDY6QxG1W47GCfmgjuGKCl7tVdPY1vpv",
	"vuiESdPaWsxECc6pBQqyMJupVHyGUijtM3R1+Zii20Ijks2fjm8djZo8HKrRK+WID9XvNP9O8/8rzTtS",
	"7AcYRGIyFgso6t6d0Us452w4NZzynzxuj725Q2O6a+QGcuEl/ex/AJea3Qv7l4t75dQrG8rRhv/JSs6M",
	"LblkZAaEP5Mqh+5Srkc9M+0VDakvFixBFdxhz9Gictq4uqqMpV8b/89SU2768MuPE9EskHs9HwsraxYq",
	"UzoXtcMCnfM3/FnHjkT+pWhuavqAmYLr0EIt0LqgYnQ2OnvBmk2FGiolE/nybHT2ktECmnug4oZCDW45",
	"DhT9b0ieyoVyvtWAohCwAFX4drSnwFuyvvudZGHj2750a6I4H40e1Dzfq8D75+V2le931VdNOBxaLwi/",
	"zs8eh4x1YcRbU5FvyOuyBD7WfdI2Wn3u/IqYIXxAsru+bmlqkYIWGhfIA1GxFEYPpfw6GIi2xtQDHehm",
	"SdwbY7kNPbE6TKC8cO9ImaLtrocwWAwNoY3o2Ji718ibetPrejqICu1RI2jvThu6fQ5mbnUbD2Snbk/b",
	"J2Wn17rLyzjlJB9lZ9qHwSuZKSI+pfiHXC1Qi5l/iXCH6OmRfB6GPhbc3XGsyc7Ao8z2cFUPjlYDDwwd",
	"tiGxT45wo7UHMf+JVypbH4XZKZ0XPe6J6VIocuFZaRDVfUAPhNp7muKLaFOv/pbe5JFsjdE93096/cSj",
	"MT9Vx0M4/rGTLsbxYnRxGsPuOYs3nJ+f3jD0CvXUpAkRMGfa/vpfdAZ+6wBXbsLv//2ZO9juHz9qvc9P",
	"mE0/1DSHLAvRLoaL48qkUIggl5GsLfeRc6IqieOCZXPjKFlxs7iOoVLx4gU3e2AV5zo8S3Mj6TFqfJev",
	"R69HbPh2/U8AAAD//1WeGrrDFgAA",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
